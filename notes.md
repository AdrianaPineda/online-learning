# React
Javascript library for building user interfaces

Characteristics:
- Declarative: easy to write
- Based on components

Installing:
- Install node.js
- sudo npm install -g create-react-app > 

https://github.com/facebook/create-react-app 

By convention create components with capital case

Proptypes: npm install prop-types --save

https://reactjs.org/docs/typechecking-with-proptypes.html

## Webpack
Config: webpack.config.js

- Create a JS project: npm init
- Install dependencies declared in package.json: npm install
- Run npm script: npm run `build:prod`
- npm install xyz --save > will add to package.json
- npm install xyz --save-dev > will add to package.json as dev dependencies

## JSX
Javascript as XML

## Others
- We use className instead of class, because class is a reserved word
- We we have more than one property of a component, indent enhances visibility

## DOM events
To link methods with our class > bind

https://reactjs.org/docs/handling-events.html

## Components state
- Properties are immutable, we cannot change this.props.x value
- State *is* mutable.

How do we change state?:
- this.setState({ ... })

## Component lifecycle
- Mount: when the component is going to be render.
- Update
- Unmount

### Mount
#### 1. constructor
- Method called *before the component is mounted* (component is not visible yet)
- We can init the state, bind events
- First method called when initializing component

#### 2. componentWillMount
- Method called just before the component is mounted (component is not visible yet)
- We can do a `setState`
- *Don't* do API calls or subscription events
- It will be called if we want to render components inside the server; and in the server we don't have the DOM to bind events

#### 3. render
- Contains all elements that will render (component's structure)
- Has the jsx in the return
- We can calculate properties

#### 4. componentDidMount
- Method called *after the component is mounted* (component is visible in the screen)
- It's launched just once
- We can bind events
- We can make API calls

### Update
#### 1. componentWillReceiveProps
- Method called when receiving new props
- It is useful to update the state with new properties

#### 2. shouldComponentUpdate
- Method that determines if the component should re-render again
- Used to optimize performance
- If the properties don't change, then I shouldn't re-render

#### 3. componentWillUpdate
- If `shouldComponentUpdate` returned true, or it `shouldComponentUpdate` wasn't handled
- Method called just before re-rendering a component
- Used to optimize performance

#### 4. render
- re-render

#### 5. componentDidUpdate
- Method called after the re-render

### Unmount
#### 1. componentWillUnmount
- Method called just before the component is removed from the app

### Error handling
#### componentDidCatch
- Method called if there is an error when rendering the component
- Error handling only happens in child components

## React Pure and Functional Components
- PureComponent: handles `shouldComponentUpdate` automatically, and it won't re-render if its properties don't change
- Functional Component: does not have a lifecycle; is a function:
~~~
function Playlist(props) {
  return(
    <div>
      {props}
    </div>
  )
}
~~~

## Smart and Dumb components
- Smart component: what does my component do?
- Dumb component: how does my component look like?

They are called:
- Smart, statefull, fat, container
- Dumb, pure, skinny, presentational components

### Presentational component
- May contain any type of component (smart or UI components)
- Allow composition with {props.children}
- Don't depend on the rest of the app
- Doesn't specify how the data is loaded or is mutated: it only receives data and presents it
- Receive data and callbacks through properties
- Rarely they have their own state
- Are written as functional components unless they need performance improvements

### Containers
- Have lifecycle
- Are concerned about the app functionality
- May contain UI components and other containers
- Don't have styles!
- Provide data to the UI components and other containers
- Provide callbacks to the UI
- They normally have state
- They call actions
- Generated by higher order components

Why do we have those two types of components:
- To separate responsibilities
- Allows for component reuse

## Portals
- Allows another component to be added to index.html different than `app`

~~~
import { createPortal } from 'react-dom';
...
createPortal()
~~~

Checkout modal.js inside src/widgets/containers

## Error handling
componentDidCatch(error, info) { ... }

## Project structure
See structure.png

home - entry point para webpack

  Home - pÃ¡gina / (container|smart)
    -> <!-- Layout - UI -->
      -> Related - UI
      -> Categories - UI
         -> Category - UI
            -> Playlist - UI
               -> Media - UI / Pure
      -> Search / (container|smart)
         -> <!-- Search Layout UI -->
            -> Input - UI
      -> Modal - (container|smart)
        -> <!-- Layout - UI -->
          -> VideoPlayer - (container|smart)
            <!-- Layout -->
             -> Video - UI state
             -> Spinner - UI
             -> Controls - UI
                -> PlayPause - UI
                  -> PlayIcon - UI
                  -> PauseIcon - UI
                -> Timer - UI
                -> ProgressBar - UI
                -> Volume - UI
                  -> VolumeIcon - UI
                -> FullScreen - UI
                  -> FullScreenIcon - UI